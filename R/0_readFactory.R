# generate read_fun for ReadInfo class
readFunFactory = function(header) {
	function(object, cn_select) {
		filename = object@filename
		cnames = object@cnames
		header = object@header
		# allow selecting all columns
		if(length(cn_select) == 1 && cn_select == "..all") {
			cn_select = cnames
		}

		# allow globbing
		filename = Sys.glob(filename)[1]
		
		
		# get index of selected cols
		stopifnot(all(cn_select %in% cnames)) 		
		col_sel_idx = which(cnames %in% cn_select)
		
		dat = txtutils::readcols(filename, 
				col_sel_idx, 
				as.integer(header), 
				1)
		dat = as.data.frame(dat, stringsAsFactors=FALSE)

		# set colnames
		dat_colnames = cnames[col_sel_idx]
		dat = setNames(dat, dat_colnames)
		
		dat
	}
}



#' An S4 class to represent information about a whitespace-delimited text file to be read into R
#' 
#' @slot filename Path of the file
#' @slot cnames character vector of column names
#' @slot header logical. Whether the first line is header
#' @slot read_fun function. The function to be used when reading this file
.ReadInfo = setClass("ReadInfo", representation(filename = 'character', 
				cnames = "character", 
				header = "logical", 
				read_fun = "function"), 
		validity = function(object) {
			errors = character()
			if(length(object@header) != 1) {
				errors = c(errors, "header should be either TRUE or FALSE.")
			}
		})



setGeneric("readInfo",
		function(filename, cnames, ...) {
			standardGeneric("readInfo")
		})

#' ReadInfo constructor
#' 
#' This function takes a file path as parameter, assuming the file is whitspace delimited, 
#' not quoted, and has a header line. It returns a ReadInfo object. 
#' 
#' @name readInfo
#' 
#' @param filename Path of the file to read
#' @return ReadInfo object
#' @examples 
#' \donotrun{
#' ri = readInfo("/Users/kaiyin/EclipseWorkspace/collapsabel2/tests/testthat/mmp13.frq")
#' getSlots("ReadInfo")
#' ri@@cnames
#' ri@@filename
#' ri@@header
#' frq = ri@@read_fun(ri, cn_select = "..all")
#' head(frq)
#' print(ri@@cnames)
#' frq1 = ri@@read_fun(ri, ri@@cnames[1:4])
#' head(frq1)
#' }
#' 
#' @author kaiyin
#' @export
setMethod("readInfo",
		signature(filename = "character", cnames = "missing"),
		function(filename) {
			filename = filePath(filename)@path
			# read the first line of file, which is the header
			first_line = read.table(filename, 
					stringsAsFactors = FALSE, nrows = 1)
			cnames = as.character(first_line[1, ])
			read_fun = readFunFactory(TRUE)
			new("ReadInfo", 
					filename = filename, 
					cnames = cnames, 
					header = TRUE, 
					read_fun = read_fun)
		})

#' @rdname readInfo
#' @export 
setMethod("readInfo",
		signature(filename = "character", cnames = "character"),
		function(filename, cnames) {
			filename = filePath(filename)@path
			# read the first line of file, this is also the first line
			# of the data, not header
			first_line = read.table(filename, 
					stringsAsFactors = FALSE, nrows = 1)
			
			# make sure cnames match the file in width
			stopifnot(length(cnames) == ncol(first_line))
			# don't skip the first line
			read_fun = readFunFactory(FALSE)
			
			new("ReadInfo", 
					filename = filename, 
					cnames = cnames, 
					header = FALSE, 
					read_fun = read_fun)
		})


#' Correct types of bim data.frame
#' 
#' CHR, BP and GDIST columns should be integers. 
#' 
#' @param bim_dat data.frame read from a .bim file
#' @return data.frame
#' 
#' @author kaiyin
#' @export
bimCorrectTypes = function(bim_dat)  {
	bim_dat_colnames = colnames(bim_dat)
	for (i in 1:ncol(bim_dat)) {
		if (bim_dat_colnames[i] == "CHR" || bim_dat_colnames[i] == "BP" || bim_dat_colnames[i] == "GDIST") {
			bim_dat[, i] = as.integer(bim_dat[, i])
		}
	}
	bim_dat
}


infoFactory = function(cnames) {
	function(filename) {
		readInfo(filename, cnames)
	}
}


#' .bim and .fam file information functions
#' 
#' These two functions \code{bimInfo, famInfo} are generated by a 
#' factory function. They are similar to readInfo, only with 
#' pre-determined colnames (since they are really known).
#'  
#' @name bim_fam_info
NULL

#' @rdname bim_fam_info
#' @export 
bimInfo = infoFactory(c("CHR", "SNP", "GDIST", "BP", "AL1", "AL2"))
#' @rdname bim_fam_info
#' @export 
famInfo = infoFactory(c("FID", "IID", "PID", "MID", "SEX", "PHE"))

readFactory = function(ext) {
	function(filename, cn_select = "..all") {
		stopifnot(tools::file_ext(filename) == ext)
		info = get(paste(ext, "Info", sep = ""))(filename)
		get(paste(ext, "CorrectTypes", sep = ""))(
				info@read_fun(info, cn_select))
	}
}



#' Read plink .bim files
#' 
#' @param filename .bim file path
#' @param cn_select a character vector for selected colnames
#' @return a data.frame
#' @examples 
#' \donotrun{
#' bim = readBim("/Users/kaiyin/EclipseWorkspace/collapsabel2/tests/testthat/mmp13.bim", 
#' 		cn_select = "..all")
#' head(bim)
#' summary(bim)
#' bim_info = bimInfo("/Users/kaiyin/EclipseWorkspace/collapsabel2/tests/testthat/mmp13.bim")
#' bim_info@@cnames
#' bim1 = bim_info@@read_fun(bim_info, c("CHR", "SNP", "BP"))
#' head(bim1)
#' }
#' 
#' @author kaiyin
#' @export
readBim = readFactory("bim")


#' Correct types of fam data.frame
#' 
#' SEX and PHE columns should be integers. 
#' 
#' @param fam_dat data.frame read from a .fam file
#' @return data.frame
#' 
#' @author kaiyin
#' @export
famCorrectTypes = function(fam_dat)  {
	fam_dat_colnames = colnames(fam_dat)
	for (i in 1:ncol(fam_dat)) {
		if (fam_dat_colnames[i] == "SEX" || fam_dat_colnames[i] == "PHE") {
			fam_dat[, i] = as.integer(fam_dat[, i])
		}
	}
	fam_dat[fam_dat == -9] = NA
	fam_dat
}


#' Read plink .fam files
#' 
#' @param filename .fam file path
#' @param cn_select a character vector for selected colnames
#' @return a data.frame
#' @examples 
#' \donotrun{
#' fam = readFam("/Users/kaiyin/EclipseWorkspace/collapsabel2/tests/testthat/mmp13.fam", cn_select = "..all")
#' head(fam)
#' summary(fam)
#' fam_info = famInfo("/Users/kaiyin/EclipseWorkspace/collapsabel2/tests/testthat/mmp13.fam")
#' fam_info@@cnames
#' fam1 = fam_info@@read_fun(fam_info, c("FID", "IID"))
#' head(fam1)
#' }
#' 
#' @author kaiyin
#' @export
readFam = readFactory("fam")