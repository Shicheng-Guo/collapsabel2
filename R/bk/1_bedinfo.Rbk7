plinkTrio <- function(bedstem, must_exist = FALSE) {
	ext_trio = c("bed", "bim", "fam")
	plink_trio = paste(bedstem, ext_trio, sep = ".")
	if(must_exist) {
		filePath(plink_trio)@path
	} else {
		plink_trio
	}
}

#' An S4 class representing info about plink files
#' 
#' Info about plink files, including the root directory, 
#' paths of plink .bed, .bim, .fam and .frq files, ff backing 
#' directories for .bim, .fam and .frq files, etc.
#' 
#' @slot main_dir Root directory where .bed, .bim and .fam files sit.
#' @slot plink_stem character. Path to the .bed file sans the extension name
#' @slot plink_trio character of length 3. Paths to .bed, .bim and .fam files (in that order).
#' @slot plink_trio_base character. Basenames of \code{plink_trio}.
#' @slot plink_frq character. Path to .frq file.
#' @slot ff_dir character. Directory for storing ff backing files.
#' @examples 
#' \donotrun{
#' x = .PlInfo()
#' x@@plink_trio = c("/tmp/a.pdf")
#' validObject(x) # error
#' }
#' 
#' @name PlInfo
#' @export 
.PlInfo = setClass("PlInfo", representation(
				main_dir = "character", 
				plink_stem = "character",
				plink_trio = "character", 
				plink_trio_base = "character", 
				plink_frq = "character"
		), 
		prototype(
				main_dir = "", 
				plink_stem = "",
				plink_trio = rep("", 3), 
				plink_trio_base = rep("", 3), 
				plink_frq = ""
		), validity = function(object) {
			obj_slots = list(
					object@main_dir,
					object@plink_stem ,
					object@plink_trio ,
					object@plink_trio_base ,
					object@plink_frq 
			) 
			names(obj_slots) = c(
					"main_dir",
					"plink_stem",
					"plink_trio",
					"plink_trio_base",
					"plink_frq"
			)
			msg = lenCheck(
					obj_slots,
					c(1, 1, 3, 3, 1))			
			if(msg != TRUE) {
				return(msg)
			}
			ext_trio = c("bed", "bim", "fam")
			if(!all(tools::file_ext(object@plink_trio) 
							== ext_trio)) {
				return(paste("Extensions should be: ", strConcat(ext_trio)))
			}
			miss_files = nonExistentFiles(object@plink_trio)
			if(length(miss_files) > 0) {
				return(miss_files)
			} else {
				return(TRUE)
			}
		})


setGeneric("plInfo",
		function(pl_info, bedstem, ff_setup, ...) {
			standardGeneric("plInfo")
		})

#' Constructor for PlInfo class
#' 
#' Populates an PlInfo object from a given plink bed filename stem (i.e. exclude extension name)
#' 
#' @param pl_info a PlInfo object, possibly empty.
#' @param bedstem path of bed file excluding extension name
#' @return a PlInfo object
#' @examples 
#' \donotrun{
#' pl_info = plInfo(.PlInfo(), "/Users/kaiyin/EclipseWorkspace/CollapsABEL/tests/testthat/mmp13")
#' isSetup(pl_info) # false
#' setup(pl_info)
#' isSetup(pl_info) # true
#' bim_ff = suppressMessages(loadBim(pl_info))
#' head(bim_ff)
#' fam_ff = loadFam(pl_info)
#' head(fam_ff)
#' summary(fam_ff[, "IID"])
#' which(fam_ff[, "IID"] == "10425")
#' frq_ff = loadFrq(pl_info)
#' head(frq_ff)
#' }
#' 
#' @author kaiyin
#' @name PlInfo_constructor
#' @export 
setMethod("plInfo",
		signature(pl_info = "PlInfo", bedstem = "character", ff_setup = "logical"),
		function(pl_info, bedstem, ff_setup) { 
			# plink trio
			ext_trio = c("bed", "bim", "fam")
			plink_trio = normalizePath(
					plinkTrio(bedstem = bedstem, must_exist = FALSE)
			) 
			plink_trio_base = basename(plink_trio)
			names(plink_trio) = names(plink_trio_base) = ext_trio
			plink_stem = tools::file_path_sans_ext(plink_trio["bed"])
			names(plink_stem) = NULL
			
			# main dir where plink files sit
			main_dir = dirname(plink_trio[1])
			
			# frq file
			plink_frq = paste(bedstem, ".frq", sep="")
			
			# return a PlInfo obj
			pl_info@main_dir = main_dir
			pl_info@plink_stem = plink_stem
			pl_info@plink_trio = plink_trio
			pl_info@plink_trio_base = plink_trio_base
			pl_info@plink_frq = plink_frq
			validObject(pl_info)
			if(ff_setup) {
				setup(pl_info)
			}
			pl_info
		})

#' @rdname PlInfo_constructor
#' @export 
setMethod("plInfo",
		signature(pl_info = "PlInfo", bedstem = "character", ff_setup = "missing"),
		function(pl_info, bedstem, ff_setup) { 
			plInfo(pl_info, bedstem, FALSE)
		})

#' @rdname PlInfo_constructor
#' @export 
setMethod("plInfo",
		signature(pl_info = "missing", bedstem = "character", ff_setup = "logical"),
		function(pl_info, bedstem, ff_setup) {
			plInfo(.PlInfo(), bedstem, ff_setup)
		})

#' @rdname PlInfo_constructor
#' @export 
setMethod("plInfo",
		signature(pl_info = "missing", bedstem = "character", ff_setup = "missing"),
		function(pl_info, bedstem, ff_setup) {
			plInfo(.PlInfo(), bedstem, FALSE)
		})

setGeneric("isSetup",
		function(pl_info, ...) {
			standardGeneric("isSetup")
		})

#' SQLite file of a PlInfo object
#' 
#' @param pl_info PlInfo object
#' @return character. Path to SQLite database file.
#' 
#' @author kaiyin
#' @export
sqliteFilePl = function(pl_info) {
	sprintf("%s.sqlite", pl_info@plink_stem)
}

#' Check if a directory containing .bed .fam and .bim files is properly setup
#'  
#' @param pl_info PlInfo object
#' @return TRUE or FALSE
#' @examples 
#' # see examples in plInfo
#' 
#' @author kaiyin
#' @docType methods
#' @export
setMethod("isSetup",
		signature(pl_info = "PlInfo"),
		function(pl_info) {
			isSQLite3(sqliteFilePl(pl_info))
		})

setGeneric("setup",
		function(pl_info, ...) {
			standardGeneric("setup")
		})

#' Setup up a directory containing plink files 
#' 
#' @param pl_info 
#' @examples 
#' # see examples in plInfo
#' 
#' @author kaiyin
#' @docType methods
#' @export
setMethod("setup",
		signature(pl_info = "PlInfo"),
		function(pl_info) {
			if(isSetup(pl_info)) {
				TRUE
			} else {
				sqlite_file = sqliteFilePl(pl_info)
				if(file.exists(sqlite_file)) {
					unlink(sqlite_file)
				}
				if(!file.exists(pl_info@plink_frq)) {
					plinkr(bfile = pl_info@plink_stem, 
							freq = "", 
							out = pl_info@plink_stem, 
							wait = TRUE)
				}
				frq = read.table(pl_info@plink_frq, header = TRUE, stringsAsFactors = FALSE)
				bim = readBim(pl_info@plink_trio["bim"])
				fam = readFam(pl_info@plink_trio["fam"])
				fam = setNames(fam, c("FID", "IID", "PID", "MID", "SEX", "PHE"))
				tryCatch({
							file.create2(sqlite_file)
							db = RSQLite::dbConnect(RSQLite::SQLite(), sqlite_file)
							RSQLite::dbWriteTable(db, "bim", bim)
							RSQLite::dbWriteTable(db, "fam", fam)
							RSQLite::dbWriteTable(db, "frq", frq)
						}, finally = {
							RSQLite::dbDisconnect(db)
						})			
			}
		})

setGeneric("nIndivPl",
		function(pl_info, ...) {
			standardGeneric("nIndivPl")
		})

#' Get number of individuals
#' 
#' @param pl_info PlInfo object
#' @export 
setMethod("nIndivPl",
		signature(pl_info = "PlInfo"),
		function(pl_info) {
			getQuery(sqliteFilePl(pl_info), "select count(iid) from fam")[1, 1]
		})

setGeneric("nSnpPl",
		function(pl_info, ...) {
			standardGeneric("nSnpPl")
		})

#' Get number of SNPs.
#' 
#' @param pl_info PlInfo object
#' @export 
setMethod("nSnpPl",
		signature(pl_info = "PlInfo"),
		function(pl_info) {
			getQuery(sqliteFilePl(pl_info), "select count(snp) from bim")[1, 1]
		})

setGeneric("bytesSnp",
		function(pl_info, ...) {
			standardGeneric("bytesSnp")
		})

#' Get number of bytes used by each SNP.
#' 
#' @param pl_info PlInfo object
#' @export 
setMethod("bytesSnp",
		signature(pl_info = "PlInfo"),
		function(pl_info) {
			as.numeric(ceiling(nIndivPl(pl_info) / 4))
		})

setGeneric("nIndivApprPl",
		function(pl_info, ...) {
			standardGeneric("nIndivApprPl")
		})

#' Get apparent number of individuals
#' 
#' @param pl_info PlInfo object
#' @export 
setMethod("nIndivApprPl",
		signature(pl_info = "PlInfo"),
		function(pl_info) {
			as.numeric(bytesSnp(pl_info) * 4)
		})


#' FID and IID columns from fam file
#' 
#' @param rbed_info RbedInfo object
#' @return data.frame of two columns "FID" and "IID"
#' 
#' @author kaiyin
#' @export
fidIid = function(pl_info) {
	getQuery(sqliteFilePl(pl_info), "select fid, iid from fam order by rowid")
}
